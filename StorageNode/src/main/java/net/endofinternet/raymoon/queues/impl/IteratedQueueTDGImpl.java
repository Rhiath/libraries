/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package net.endofinternet.raymoon.queues.impl;

import com.almworks.sqlite4java.SQLiteConnection;
import com.almworks.sqlite4java.SQLiteException;
import com.almworks.sqlite4java.SQLiteStatement;
import com.google.gson.Gson;
import net.endofinternet.raymoon.persistence.exceptions.PersistenceException;
import net.endofinternet.raymoon.persistence.implementation.AbstractTableDataGateway;
import net.endofinternet.raymoon.persistence.interfaces.ConnectionProvider;
import net.endofinternet.raymoon.persistence.utilities.Tables;
import net.endofinternet.raymoon.queues.IteratedQueueTDG;
import net.endofinternet.raymoon.queues.QueueToken;

/**
 *
 * @author raymoon
 */
public class IteratedQueueTDGImpl extends AbstractTableDataGateway implements IteratedQueueTDG {

    public IteratedQueueTDGImpl(ConnectionProvider connectionProvider) {
        super(connectionProvider);
    }
    
    /**
     *
     * @throws PersistenceException
     */
    @Override
    public void createTableIfMissing() throws PersistenceException {
        ConnectionProvider provider = super.getConnectionProvider();
        SQLiteConnection connection = provider.aquireConnection();
        try {
            if (!Tables.tableExists(connection, "ITERATEDQUEUES")) {
                connection.prepare("create table ITERATEDQUEUES ("
                        + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                        + "value TEXT,"
                        + "type TEXT"
                        + ")").stepThrough();
            }

            if (!Tables.tableExists(connection, "QUEUEITERATORS")) {
                connection.prepare("create table QUEUEITERATORS ("
                        + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                        + "type TEXT,"
                        + "name TEXT,"
                        + "pos, int"
                        + ")").stepThrough();
            }
        } catch (SQLiteException ex) {
            throw new PersistenceException("failed to create tables for queues", ex);
        } finally {
            provider.releaseConnection();

        }
    }

    @Override
    public <T> void enqueue(Class<T> type, T value) throws PersistenceException {
        ConnectionProvider provider = super.getConnectionProvider();
        SQLiteConnection connection = provider.aquireConnection();
        try {
            String jsonValue = new Gson().toJson(value);
            connection.prepare("insert  into ITERATEDQUEUES (type, value) VALUES (?,?)").bind(1, type.getCanonicalName()).bind(2, jsonValue).stepThrough();
        } catch (SQLiteException ex) {
            throw new PersistenceException("failed to insert queue element of type " + type.getCanonicalName(), ex);
        } finally {
            provider.releaseConnection();
        }
    }

    @Override
    public <T> void createIterator(Class<T> type, String iteratorName) throws PersistenceException {
        ConnectionProvider provider = super.getConnectionProvider();
        SQLiteConnection connection = provider.aquireConnection();
        try {
            connection.prepare("insert  into QUEUEITERATORS (type, name, pos) VALUES (?,?, -1)").bind(1, type.getCanonicalName()).bind(2, iteratorName).stepThrough();
        } catch (SQLiteException ex) {
            throw new PersistenceException("failed to insert queue element of type " + type.getCanonicalName(), ex);
        } finally {
            provider.releaseConnection();
        }
    }

    @Override
    public void dequeue(QueueToken token) throws PersistenceException {
        if (token instanceof IteratedQueueTokenImpl) {
            IteratedQueueTokenImpl typedToken = (IteratedQueueTokenImpl) token;
            ConnectionProvider provider = super.getConnectionProvider();
            SQLiteConnection connection = provider.aquireConnection();
            try {
                connection.prepare("update QUEUEITERATORS SET pos = ? WHERE type = ? and name = ?").bind(2, typedToken.getQueueType()).bind(3, typedToken.getIteratorName()).bind(1, typedToken.getId()+1).stepThrough();
            } catch (SQLiteException ex) {
                throw new PersistenceException("failed to remove queue element with id " + typedToken.getId(), ex);
            } finally {
                provider.releaseConnection();
            }
        } else {
            throw new PersistenceException("provided token instance not generated by this table data gateway");
        }
    }

    @Override
    public <T> QueueToken<T> peekAtNextQueueElement(Class<T> type, String iteratorName) throws PersistenceException {
        ConnectionProvider provider = super.getConnectionProvider();
        SQLiteConnection connection = provider.aquireConnection();
        try {
            long position = getIteratorPosition(connection, iteratorName, type);
            return getNextQueueElement(connection, iteratorName, type, position);

        } catch (SQLiteException ex) {
            throw new PersistenceException("failed to get queue element", ex);
        } finally {
            provider.releaseConnection();
        }
    }

    private <T> long getIteratorPosition(SQLiteConnection connection, String iteratorName, Class<T> type) throws SQLiteException, PersistenceException {
        SQLiteStatement statement = connection.prepare("select pos from QUEUEITERATORS WHERE name = ? and type = ? ORDER BY id ASC LIMIT 1").bind(1, iteratorName).bind(2, type.getCanonicalName());
        try {
            while (statement.step()) {
                return statement.columnLong(0);
            }
            throw new PersistenceException("failed to get queue element");

        } finally {
            statement.dispose();
        }
    }

    private <T> QueueToken<T> getNextQueueElement(SQLiteConnection connection, String iteratorName, Class<T> type, long position) throws SQLiteException, PersistenceException {
        SQLiteStatement statement = connection.prepare("select value, id from ITERATEDQUEUES WHERE id > ? and type = ? ORDER BY id ASC LIMIT 1").bind(1, position).bind(2, type.getCanonicalName());
        try {
            while (statement.step()) {

                T value = new Gson().fromJson(statement.columnString(0), type);
                return new IteratedQueueTokenImpl<T>(value, statement.columnLong(1), iteratorName, type.getCanonicalName());

            }
            throw new PersistenceException("failed to get queue element");

        } finally {
            statement.dispose();
        }
    }
}
